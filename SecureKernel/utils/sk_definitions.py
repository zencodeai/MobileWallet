import random
import datetime
import string
import hashlib
import json

from enum import Enum

# JSON encoder for SK definitions classes
class SKJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        # if dict as name attribute, return it
        if hasattr(obj, 'to_dict'):
            d = obj.to_dict()
            d['type'] = obj.__class__.__name__
            return d if 'name' in d else None
        else:
            return None

def get_skheader(date: str) -> str:
    return f"""#pragma once

// 
// Secure kernel definitions
// This file is auto-generated by sk_definitions.py script
// Do not edit this file manually
// Generated on: {date}
//\n
"""


# Interface for all SK classes
class SKInterface:
    def __init__(self):
        pass

    def __str__(self):
        return self.__class__.__name__
    
    def to_dict(self):
        return dict()


class SKHeader(SKInterface):

    def __init__(self):
        super().__init__()
        self.date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # override __str__ method
    def __str__(self):
        return get_skheader(self.date)

    # override to_dict method
    def to_dict(self):
        return dict(date=self.date)


class SKSeed(SKInterface):

    def __init__(self, seed: int):
        super().__init__()
        self.seed = seed
        random.seed(self.seed)

    # override __str__ method
    def __str__(self):
        return ""

    # override to_dict method
    def to_dict(self):
        return dict(seed=self.seed)


class SKSection(SKInterface):

    def __init__(self, section: str):
        super().__init__()
        self.section = section

    # override __str__ method
    def __str__(self):
        return '\n//' + 80*'-' + '\n// ' + self.section + '\n\n'
    
    # override to_dict method
    def to_dict(self):
        return dict(section=self.section)


class SKRndUInt32(SKInterface):

    SKRndValue = dict()

    def __init__(self, name: str, description: str):

        super().__init__()
    
        self.name = name
        self.description = description

        value = random.randint(0x70000000, 0xFFFFFFFF)
        while value in self.SKRndValue:
            value = random.randint(0x70000000, 0x7FFFFFFF)

        self.SKRndValue[value] = self
        self.value = value
    
    # override __str__ method
    def __str__(self):
        return f'// {self.description}\n#define {self.name} ((uint32_t)(0x{self.value:08X}))\n'

    # override to_dict method
    def to_dict(self):
        return dict(name=self.name, description=self.description, value=self.value)


# Error category enum
class SKErrorCategory(Enum):
    SK_ERROR_CATEGORY_NONE = 0
    SK_ERROR_CATEGORY_SYSTEM = 1
    SK_ERROR_CATEGORY_APPLICATION = 2
    SK_ERROR_CATEGORY_INPUT = 3
    SK_ERROR_CATEGORY_MEMORY = 4
    SK_ERROR_CATEGORY_FILE = 5
    SK_ERROR_CATEGORY_STORE = 6
    SK_ERROR_CATEGORY_MTLS = 7
    SK_ERROR_CATEGORY_TX = 8
    SK_ERROR_CATEGORY_CERT = 9
    SK_ERROR_CATEGORY_SESSION = 10

# Error categories class
class SKErrorCategories(SKInterface):
    
        def __init__(self):
            super().__init__()
    
        # override __str__ method
        def __str__(self):
            lines = [f'#define {e.name} ({e.value})\n' for e in SKErrorCategory]
            return ''.join(lines)

        # override to_dict method
        def to_dict(self):
            return dict(name="SK_ERROR_CATEGORIES", categories=[dict(name=e.name, value=e.value) for e in SKErrorCategory])


# Error class
class SKError(SKInterface):

    SKRndCodes = dict()

    @staticmethod
    def SK_ERROR_CODE(category: SKErrorCategory) -> int:
        return random.randint(0x70000000, 0xFFFFFFFF) & 0xFFFFFFF0 | category.value

    def __init__(self, name: str, category: SKErrorCategory, description: str):
        super().__init__()
        self.name = name
        self.category = category
        self.description = description

        code = self.SK_ERROR_CODE(category)
        while code in self.SKRndCodes:
            code = self.SK_ERROR_CODE(category)

        self.SKRndCodes[code] = self
        self.code = code

    # override __str__ method
    def __str__(self):
        return f'// {self.description} ({self.category.name})\n#define {self.name} ((uint32_t)(0x{self.code:08X}))\n'
    
    # override to_dict method
    def to_dict(self):
        return dict(name=self.name, category=self.category.name, description=self.description, code=self.code)


# Random string of size n class
class SKRndString(SKInterface):
    
        SKRndString = dict()

        # Generate random string of size n
        def gen(self, n: int) -> str:
            return ''.join(random.choices(string.ascii_uppercase + string.digits, k=n))

        # Generate value
        def gen_value(self) -> str:
            value = self.gen(self.n)
            while value in self.SKRndString:
                value = self.gen(self.n)
            self.SKRndString[value] = self
            return value

        def __init__(self, name: str, description: str, n: int):
            super().__init__()
            self.name = name
            self.description = description
            self.n = n
            self.value = self.gen_value()
    
        # override __str__ method
        def __str__(self):
            return f'// {self.description}\n#define {self.name} ((const char*)("{self.value}"))\n'
        
        # override to_dict method
        def to_dict(self):
            return dict(name=self.name, description=self.description, value=self.value)


# Database key class
class SKDatabaseKey(SKInterface):

    SKRndKey = dict()

    # Generate random string of size n
    def gen(self, n: int) -> str:
        return chr(random.choice(self.prefix)) + ''.join(random.choices(string.ascii_uppercase + string.digits, k=(n - 1)))

    # Generate value
    def gen_value(self) -> str:
        value =  self.gen(self.size)
        while value in self.SKRndKey:
            value = self.gen(self.size)
        self.SKRndKey[value] = self
        return value

    def __init__(self, name: str, description: str, prefix: range = range(ord('A'), ord('N')), size: int = 16):
        super().__init__()
        self.name = name
        self.description = description
        self.prefix = prefix
        self.size = size
        self.value = self.gen_value()

    # override __str__ method
    def __str__(self):
        # convert string to hex
        value_hex = '{' + ''.join([f'0x{b:02X}, ' for b in bytearray(self.value, 'utf-8')]) + '0x00}'
        return f'''
// {self.description}
#define {self.name} ((const char*)("{self.value}"))
#define {self.name}_HEX {value_hex}
#define {self.name}_SIZE ({self.size + 1})
'''

    # override to_dict method
    def to_dict(self):
        return dict(name=self.name, description=self.description, value=self.value)


# Store pathname class
class SKStorePathname(SKInterface):

    # Generate random string of size n
    def gen(self, n: int) -> str:
        return chr(random.choice(range(ord('A'), ord('Z')))) + ''.join(random.choices(string.ascii_uppercase + string.digits, k=(n - 1)))

    def __init__(self, name: str, description: str, prefix: str, ext:str = '.bin', size: int = 16):
        super().__init__()
        self.name = name
        self.description = description
        self.prefix = prefix
        self.ext = ext
        self.size = size
        self.value =  f'{self.prefix}/{self.gen(self.size)}{self.ext}'

    # override __str__ method
    def __str__(self):
        # convert string to hex
        value_hex = '{' + ''.join([f'0x{b:02X}, ' for b in bytearray(self.value, 'utf-8')]) + '0x00}'
        return f'''
// {self.description}
#define {self.name} ((const char*)("{self.value}"))
#define {self.name}_HEX {value_hex}
#define {self.name}_SIZE ({len(self.value) + 1})
'''

    # override to_dict method
    def to_dict(self):
        return dict(name=self.name, description=self.description, value=self.value)


# Masked Binary data class with name, description and value as byte array
class SMaskedKBinaryData(SKInterface):
        
        # Convert byte array to C array of hex strings with break line every 16 bytes
        def to_hex(self, value: bytearray) -> str:

            def to_hex_str(i: int, b: str) -> str:
                return f'0x{b:02X}, ' + ('\\\n' if i % 16 == 15 else '')

            return '{ \\\n' + ''.join([to_hex_str(i, b) for i ,b in enumerate(value)]) + '}\n'

        # Compute SHA256 hash of the value as byte array
        def hash(self) -> None:
            self.csum = hashlib.sha256(self.value).digest()

        # Genarate mask and mask value
        def gen_and_mask(self) -> None:
            self.mask = bytearray(random.getrandbits(8) for _ in range(len(self.value)))
            for i in range(len(self.value)):
                self.value[i] ^= self.mask[i]

        def __init__(self, name: str, description: str, value: bytearray):
            super().__init__()
            self.plain = value.copy()
            self.name = name
            self.description = description
            self.value = value
            self.hash()
            self.gen_and_mask()

        # override __str__ method
        def __str__(self):
            str_value = self.to_hex(self.value)
            str_mask = self.to_hex(self.mask)
            str_csum = self.to_hex(self.csum)
            return f"""
// {self.description}
#define {self.name} {str_value}
// Size
#define {self.name}_SIZE ({len(self.value)})\n
// Mask
#define {self.name}_MASK {str_mask}
// Checksum
#define {self.name}_CSUM {str_csum}
"""

        # override to_dict method
        def to_dict(self):
            return dict(name=self.name, description=self.description, value=[b for b in self.plain])


# Masked Binary data class from file
class SMaskedKBinaryDataFromFile(SMaskedKBinaryData):
    
    def __init__(self, name: str, description: str, file: str):
        with open(file, 'rb') as f:
            super().__init__(name, description, bytearray(f.read()))


class SKMaskedBinaryRandomData(SMaskedKBinaryData):
    
    def __init__(self, name: str, description: str, size: int):
        super().__init__(name, description, bytearray(random.getrandbits(8) for _ in range(size)))


# Masked Binary data simple
class SKMaskedBinarySimple(SMaskedKBinaryData):
    
    def __init__(self, name: str, description: str, size: int):
        value = bytearray(i % 256 for i in range(size))
        super().__init__(name, description, value)


SKDefinitions = [
    SKHeader(),

    SKSeed(123456),

    SKSection('Error categories'),
    SKErrorCategories(),

    SKSection('Generic errors'),
    SKError('SK_ERROR_FAILED', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Generic error'),
    SKError('SK_ERROR_INVALID_STATE', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Invalid state'),
    SKError('SK_ERROR_BUFFER_OVERFLOW', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Buffer overflow'),
    SKError('SK_ERROR_INVALID_PARAMETER', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Invalid parameter'),

    SKSection('Secure store errors'),
    SKError('SK_ERROR_SQLITE', SKErrorCategory.SK_ERROR_CATEGORY_STORE, 'SQLite error'),

    SKSection('MBED TLS errors'),
    SKError('SK_ERROR_MBEDTLS', SKErrorCategory.SK_ERROR_CATEGORY_MTLS, 'MBED TLS generic error'),

    SKSection('SKRandom errors'),
    SKError('SK_ERROR_RND', SKErrorCategory.SK_ERROR_CATEGORY_SYSTEM, 'Random error'),

    SKSection('Transaction list errors'),
    SKError('SK_ERROR_TX_LIST', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'Transaction list error'),
    SKError('SK_ERROR_TX_CHKS', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'Invalid chacksum'),
    SKError('SK_ERROR_TX_SIGN', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'Failed to verify signature'),
    SKError('SK_ERROR_TX_AMNT', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'Invalid amount/balance in secure store'),
    SKError('SK_ERROR_TX_TIME', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'Invalid timestamp in secure store'),
    SKError('SK_ERROR_TX_PADD', SKErrorCategory.SK_ERROR_CATEGORY_TX, 'invalid data padding in secure store'),

    SKSection('Certificate errors'),
    SKError('SK_ERROR_CERT_PARSE', SKErrorCategory.SK_ERROR_CATEGORY_CERT, 'Failed to parse certificate'),
    SKError('SK_ERROR_CRL_PARSE', SKErrorCategory.SK_ERROR_CATEGORY_CERT, 'Certificate revocation list parse error'),
    SKError('SK_ERROR_CERT_VERIFY', SKErrorCategory.SK_ERROR_CATEGORY_CERT, 'Certificate chain verification failed'),
    SKError('SK_ERROR_CERT_SIGN', SKErrorCategory.SK_ERROR_CATEGORY_CERT, 'Signature verification failed'),

    SKSection('Online state machine errors'),
    SKError('SK_ERROR_ONLINE_INVALID_STATE', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Invalid online state'),
    SKError('SK_ERROR_ONLINE_NEWTX_STATE', SKErrorCategory.SK_ERROR_CATEGORY_SESSION, 'Invalid new transaction state'),

    SKSection('Session related errors'),
    SKError('SK_ERROR_STORE_EXISTS', SKErrorCategory.SK_ERROR_CATEGORY_SESSION, 'Store already exists'),
    SKError('SK_ERROR_INVALID_PROV_DATA', SKErrorCategory.SK_ERROR_CATEGORY_SESSION, 'Invalid provisioning data'),

    SKSection('P2P related errors'),
    SKError('SK_ERROR_P2P_MSG', SKErrorCategory.SK_ERROR_CATEGORY_SESSION, 'Invalid P2P message'),

    SKSection('Secure kernel API errors'),
    SKError('SK_ERROR_API', SKErrorCategory.SK_ERROR_CATEGORY_APPLICATION, 'Secure kernel API error'),

    SKSection('Constants'),
    SKSection('Boolean values'),
    SKRndUInt32('SK_FALSE', 'False value'),
    SKRndUInt32('SK_TRUE', 'True value'),

    SKSection('Common state mahine states'),
    SKRndUInt32('SK_ST_RESET', 'Reset state'),
    SKRndUInt32('SK_ST_INVALID', 'Invalid state'),
    SKRndUInt32('SK_ST_DONE', 'Done state'),
    
    SKSection('Online state mahine states'),
    SKRndUInt32('SK_ST_ONLINE_RESET', 'Reset state'),
    SKRndUInt32('SK_ST_ONLINE_DONE', 'Done state'),
    SKRndUInt32('SK_ST_ONLINE_INIT', 'Init state'),
    SKRndUInt32('SK_ST_ONLINE_SRV_RESP', 'Waiting for ECDH server response'),
    SKRndUInt32('SK_ST_ONLINE_SRV_RESP_BALANCE', 'Waiting for ECDH server response with balance initialization'),
    SKRndUInt32('SK_ST_ONLINE_TX_RESP', 'Waiting for transaction upload server response'),
    SKRndUInt32('SK_ST_ONLINE_TUID_RESP', 'Waiting for TUID request server response'),

    SKSection('Provisioning state mahine states'),
    SKRndUInt32('SK_ST_PROV_RESET', 'Reset state'),
    SKRndUInt32('SK_ST_PROV_DONE', 'Done state'),
    SKRndUInt32('SK_ST_PROV_INIT', 'Init state'),
    SKRndUInt32('SK_ST_PROV_SRV_RESP', 'Waiting for ECDH server response'),
    SKRndUInt32('SK_ST_PROV_PARAMS', 'Waiting for provisioning parameters'),

    SKSection('Offline P2P payor (sender) state mahine states'),
    SKRndUInt32('SK_ST_P2PS_RESET', 'Reset state'),
    SKRndUInt32('SK_ST_P2PS_DONE', 'Done state'),
    SKRndUInt32('SK_ST_P2PS_INIT', 'Init state'),
    SKRndUInt32('SK_ST_P2PS_RESP', 'Waiting for counterparty ECDH response'),
    SKRndUInt32('SK_ST_P2PS_RCPT', 'Waiting for counterparty receipt'),

    SKSection('Offline P2P payee (receiver) state mahine states'),
    SKRndUInt32('SK_ST_P2PR_RESET', 'Reset state'),
    SKRndUInt32('SK_ST_P2PR_DONE', 'Done state'),
    SKRndUInt32('SK_ST_P2PR_INIT', 'Init state'),
    SKRndUInt32('SK_ST_P2PR_PARAMS', 'Waiting for counterparty ECDH parameters'),
    SKRndUInt32('SK_ST_P2PR_TXDATA', 'Waiting for counterparty transaction data'),
    SKRndUInt32('SK_ST_P2PR_ACK', 'Waiting for receipt acknowledgement'),

    SKSection('Provisioning conastants'),
    SKMaskedBinaryRandomData('SK_PROV_SHARED_IV', 'Shared IV for provisioning parameters encryption', 16),

    SKSection('Offline P2P payor constants'),
    SKMaskedBinaryRandomData('SK_P2P_SHARED_IV', 'Shared IV for shared key establishement', 16),

    SKSection('Key types'),
    SKRndUInt32('SK_CST_KEY_TYPE_NONE', 'No key type'),
    SKRndUInt32('SK_CST_KEY_TYPE_AES_GCM_128', 'AES-GCM-128 key type'),
    SKRndUInt32('SK_CST_KEY_TYPE_ECDSA_P256', 'ECDSA P-256 key type'),

    SKSeed(654321),

    SKSection('SK context commands'),
    SKRndUInt32('SK_CMD_STATUS', 'Get secure kernel status'),
    SKRndUInt32('SK_CMD_OFFLINE', 'Set offline mode'),
    SKRndUInt32('SK_CMD_ONLINE', 'Set online mode'),
    SKRndUInt32('SK_CMD_TX_ONLINE', 'Start online transaction'),
    SKRndUInt32('SK_CMD_TX_OFFLINE_PAYOR', 'Start offline P2P payor transaction'),
    SKRndUInt32('SK_CMD_TX_OFFLINE_PAYEE', 'Start offline P2P payee transaction'),
    SKRndUInt32('SK_CMD_PROCESS_MSG', 'Process message'),
    SKRndUInt32('SK_CMD_DECRYPT', 'Decrypt and verify signature of payload data using online session key'),

    SKSection('SK context states'),
    SKRndUInt32('SK_CTX_INV', 'Invalid state'),
    SKRndUInt32('SK_CTX_ERROR', 'Error state'),
    SKRndUInt32('SK_CTX_PROV', 'Expecting provisioning data'),
    SKRndUInt32('SK_CTX_INIT', 'Expecting balance initialization'),
    SKRndUInt32('SK_CTX_READY', 'Ready for offline/online transactions'),

    SKSection('Secure store related name and data'),
    SKStorePathname('SK_STORE_PATHNAME', 'Secure store pathname', './'),

    SKSection('Application key store keys'),
    SKRndString('SK_APP_KEY_SYM', 'Application key', 16),
    SKRndString('SK_APP_KEY_ASYM', 'Application key', 16),

    SKSection('MBED TLS crypto static key'),
    SKMaskedBinaryRandomData('SK_CRYPTO_STATC_KEY', 'MBED TLS crypto module static key', 16),

    SKSection('Secure store db keys for PRNG state'),
    SKDatabaseKey('SK_DB_PRNG', 'PRNG state'),

    SKSection('Simulated app key store keys'),
    SKDatabaseKey('SK_DB_SYM', 'Symmetric AES-128 key'),
    SKDatabaseKey('SK_DB_ASYM', 'Asymmetric ECDSA key'),

    SKSection('Provisioning related related db keys'),
    SKDatabaseKey('SK_DB_INST_SIG_KEY', 'DB key instance ECDSA key pair'),
    SKDatabaseKey('SK_DB_INST_CERT_VAL', 'DB key instance certificate'),
    SKDatabaseKey('SK_DB_INST_CERT_TAG', 'DB key instance certificate tag'),

    SKSection('Transaction management related db keys'),
    SKDatabaseKey('SK_DB_TX_HEAD_VAL', 'Transaction data list head'),
    SKDatabaseKey('SK_DB_TX_HEAD_TAG', 'Transaction data list head tag'),
    SKDatabaseKey('SK_DB_TX_SIG_VAL', 'Transaction data list signature'),
    SKDatabaseKey('SK_DB_TX_SIG_TAG', 'Transaction data list signature tag'),
    SKDatabaseKey('SK_DB_TX_TMP_VAL', 'Transaction data list signature'),
    SKDatabaseKey('SK_DB_TX_TMP_TAG', 'Transaction data list signature tag'),
    SKDatabaseKey('SK_DB_TX_IUID_VAL', 'Application instance IUD (certificate hash)'),
    SKDatabaseKey('SK_DB_TX_IUID_TAG', 'Application instance IUD tag'),
    SKDatabaseKey('SK_DB_TX_PER_KEY', 'DB key for data persistence key'),
    SKDatabaseKey('SK_DB_TX_ENC_KEY', 'DB key for transaction data cipher key'),
    SKDatabaseKey('SK_DB_TX_SIG_KEY', 'DB key for transaction list signature key'),

    SKSection('Application key store simulator keys'),
    SKMaskedBinaryRandomData('SK_APPKEYS_SYM_IV', 'Symmetric AES-128 IV', 16),
    SKMaskedBinaryRandomData('SK_APPKEYS_SYM_SALT', 'Symmetric AES-128 salt', 16),

    SKSection('Masked constants for AES-GCM encryption'),
    SKMaskedBinaryRandomData('SK_UNWRAP_IV', 'Unwrap key IV', 16),
    SKMaskedBinaryRandomData('SK_UNWRAP_DATA', 'Unwrap key data ', 32),

    SKMaskedBinaryRandomData('SK_STORE_VAL_IV', 'Store encrypted value IV', 16),
    SKMaskedBinaryRandomData('SK_STORE_VAL_DATA', 'Store encrypted value data', 32),

    SKMaskedBinaryRandomData('SK_STORE_TX_IV', 'Transaction encryption value IV', 16),
    SKMaskedBinaryRandomData('SK_STORE_TX_DATA', 'Transaction encryption value data', 32),

    SKSection('Root certificate'),
    SMaskedKBinaryDataFromFile('SK_ROOT_CERT', 'Root certificate', 'data/ca_fintech_inc_root_cert.der'),

    SKSection('Backend certificate'),
    SMaskedKBinaryDataFromFile('SK_BACKEND_CERT', 'Backend certificate', 'data/ca_fintech_inc_backend_cert.der'),
    SMaskedKBinaryDataFromFile('SK_BACKEND_KEY', 'Backend private key (test only)', 'data/ca_fintech_inc_backend_key.der'),

    SKSection('Test related constants'),
    SKDatabaseKey('SK_DB_TEST_SYM', 'Symmetric AES-128 key db key for test'),
    SKDatabaseKey('SK_DB_TEST_VAL', 'BD key for test value'),
    SKDatabaseKey('SK_DB_TEST_TAG', 'BD key for test value tag'),
    SKDatabaseKey('SK_DB_TEST_HEAD_VAL', 'List head BD key for test value'),
    SKDatabaseKey('SK_DB_TEST_HEAD_TAG', 'List head tag BD key for test value tag'),

    SMaskedKBinaryDataFromFile('SK_TEST_X509_CERT', 'X509 test DER certificate', 'data/ca_fintech_inc_test_cert.der'),
    SMaskedKBinaryDataFromFile('SK_TEST_X509_KEY', 'X509 test DER private key', 'data/ca_fintech_inc_test_key.der'),

    SMaskedKBinaryDataFromFile('SK_TEST1_X509_CERT', 'X509 test 1 DER certificate', 'data/ca_fintech_inc_test1_cert.der'),
    SMaskedKBinaryDataFromFile('SK_TEST1_X509_KEY', 'X509 test 1 DER private key', 'data/ca_fintech_inc_test1_key.der'),

    SMaskedKBinaryDataFromFile('SK_TEST2_X509_CERT', 'X509 test 2 DER certificate', 'data/ca_fintech_inc_test1_cert.der'),
    SMaskedKBinaryDataFromFile('SK_TEST2_X509_KEY', 'X509 test 2 DER private key', 'data/ca_fintech_inc_test1_key.der'),
]

# Generate definitions file
def sk_generate_definitions(filename: str, definitions: list):
    with open(filename, 'w') as f:
        for definition in definitions:
            f.write(str(definition))

# Generate definitions json file
def sk_generate_definitions_json(filename: str, definitions: list):
    with open(filename, 'w') as f:
        json.dump(definitions, f, indent=4, cls=SKJSONEncoder)

# Entry point
if __name__ == '__main__':
    sk_generate_definitions('src/inc/sk_definitions.hpp', SKDefinitions)
    sk_generate_definitions_json('wrapper/sk_definitions.json', SKDefinitions)
